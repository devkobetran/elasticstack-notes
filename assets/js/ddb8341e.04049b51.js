"use strict";(self.webpackChunkelasticstack_notes=self.webpackChunkelasticstack_notes||[]).push([[334],{8413:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>g});var a=t(4848),s=t(8453);const i={sidebar_position:6},r="Aggregations",o={id:"tutorial/aggregations",title:"Aggregations",description:"Metric Aggregations",source:"@site/docs/tutorial/aggregations.md",sourceDirName:"tutorial",slug:"/tutorial/aggregations",permalink:"/elasticstack-notes/docs/tutorial/aggregations",draft:!1,unlisted:!1,editUrl:"https://github.com/devkobetran/elasticstack-notes/docs/tutorial/aggregations.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Controlling Query Results",permalink:"/elasticstack-notes/docs/tutorial/controlling-query-results"},next:{title:"Improving Search Results",permalink:"/elasticstack-notes/docs/tutorial/improving-search-results"}},l={},g=[{value:"Metric Aggregations",id:"metric-aggregations",level:2},{value:"Introduction to bucket aggregations",id:"introduction-to-bucket-aggregations",level:2},{value:"Document counts are approximate",id:"document-counts-are-approximate",level:2},{value:"Nested Aggregations",id:"nested-aggregations",level:2},{value:"Filtering out Documents",id:"filtering-out-documents",level:2},{value:"Defining bucket rules with filters",id:"defining-bucket-rules-with-filters",level:2},{value:"Range Aggregations",id:"range-aggregations",level:2},{value:"Histograms",id:"histograms",level:2},{value:"Global Aggregations",id:"global-aggregations",level:2},{value:"Missing Field Values",id:"missing-field-values",level:2},{value:"Aggregating Nested Objects",id:"aggregating-nested-objects",level:2}];function c(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"aggregations",children:"Aggregations"})}),"\n",(0,a.jsx)(e.h2,{id:"metric-aggregations",children:"Metric Aggregations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:(0,a.jsx)(e.a,{href:"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics.html",children:"Metric Aggregations"})}),"\n",(0,a.jsx)(e.li,{children:"Single-value numeric metric aggregations outputs a single value"}),"\n",(0,a.jsx)(e.li,{children:"Multi-value metric aggregations outputs multiple values"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "total_salesmen": {\n            "cardinality": {\n                "field": "salesman.id"\n            }\n        },\n\n    }\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsx)(e.p,{children:"cardinality aggregation produces approximate numbers."})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "values_count": {\n            "value_count": {\n                "field": "total_amount"\n            }\n        }\n\n    }\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsxs)(e.p,{children:["So the ",(0,a.jsx)(e.code,{children:"value_account"})," aggregation gives us the number of values that the aggregation used for doing its work."]})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "stats": {\n            "field": "total_amount"\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.admonition,{type:"note",children:(0,a.jsxs)(e.p,{children:["The ",(0,a.jsx)(e.code,{children:"stats"})," aggregation calculates the numbers returned by the min, max, sum, avg and value count aggregations."]})}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-bucket-aggregations",children:"Introduction to bucket aggregations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Bucket aggregations create buckets of documents based on some criterion"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "status_terms": {\n            "terms": {\n                "field": "status.keyword",\n                "missing": "N/A",\n                "min_doc_count": 0,\n                "order": {\n                    "_key": "asc"\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"document-counts-are-approximate",children:"Document counts are approximate"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["The reason why counts are not always accurate is because of the distributed nature of an Elasticsearch cluster.","\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Since an index is distributed across multiple shards, at least by default."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(e.li,{children:"The way the terms segregation works is that the coordinating note that is responsible for handling the search request prompts each shard for its top unique terms."}),"\n",(0,a.jsx)(e.li,{children:"The coordinating note then takes the results from each of the shards and uses those to compute the final result."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"nested-aggregations",children:"Nested Aggregations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "query": {\n        "range": {\n            "total_amount": {\n                "gte": 100\n            }\n        }\n    }\n    "aggs": {\n        "status_terms": {\n            "terms": {\n                "field": "status.keyword",\n            },\n            "aggs": {\n                "status_stats": {\n                    "stats": {\n                        "field": "total_amount"\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.admonition,{type:"note",children:[(0,a.jsx)(e.p,{children:"So the terms aggregation runs in the context of the query."}),(0,a.jsx)(e.p,{children:"While the stats aggregation runs in the context of its parent aggregation, being a bucket aggregation."})]}),"\n",(0,a.jsxs)(e.admonition,{type:"note",children:[(0,a.jsx)(e.p,{children:"Metric aggregations produce simple results and cannot contain sub-aggregations."}),(0,a.jsx)(e.p,{children:"Bucket aggregations may contain sub aggregations which then operate on the buckets produced by the parent bucket aggregation."})]}),"\n",(0,a.jsx)(e.h2,{id:"filtering-out-documents",children:"Filtering out Documents"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "low_value": {\n            "filter": {\n                "total_amount": {\n                    "lt": 50\n                }\n            }\n        },\n        "aggs": {\n            "avg_amount": {\n                "avg": {\n                    "field": "total_amount"\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"The avg aggregation runs within the context of the filter, meaning that it only aggregates the documents that match the range query."}),"\n",(0,a.jsx)(e.li,{children:"The range query is a top-level aggregation, meaning that it runs in the context of the query, which is an implicit match_all query in this case, and the avg aggregation runs in the context of the filter aggregation, meaning that some documents have been filtered out."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"defining-bucket-rules-with-filters",children:"Defining bucket rules with filters"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:'GET /recipe/_search\n{\n    "size": 0,\n    "aggs": {\n        "my_filter": {\n            "filters": {\n                "filters": {\n                    "pasta": {\n                        "match": {\n                            "title": "pasta"\n                        }\n                    },\n                    "spaghetti": {\n                        "match": {\n                            "title" "spaghetti"\n                        }\n                    }\n                }\n            },\n            "aggs": {\n                "avg_rating": {\n                    "avg": {\n                        "field": "ratings"\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"This will take any documents whose title contains the term pasta and place them within a bucket named pasta. Likewise for Spaghetti."}),"\n",(0,a.jsx)(e.li,{children:"Thus, two buckets are created"}),"\n",(0,a.jsx)(e.li,{children:"Also, calculated the average ratings for each of the buckets by using the avg aggregation."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"range-aggregations",children:"Range Aggregations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "amount_distribution": {\n            "range": {\n                "field": "total_amount",\n                "ranges": [\n                    {\n                        "to": 50\n                    },\n                    {\n                        "from": 50,\n                        "to": 100\n                    },\n                    {\n                        "from": 100\n                    }\n                ]\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "purchased_ranges": {\n            "date_range": {\n                "field": "purchased_at",\n                "format": "yyyy-MM-dd",\n                "keyed": true,\n                "ranges": [\n                    {\n                        "from": "2016-01-01",\n                        "to": "2016-01-01||+6M",\n                        "key": "first_half"\n                    },\n                    {\n                        "from": "2016-01-01||+6M",\n                        "to": "2016-01-01||+1y",\n                        "key": "second_half"\n                    },\n                ]\n            },\n            "aggs": {\n                "bucket_stats": {\n                    "stats": {\n                        "field": "total_amount"\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"histograms",children:"Histograms"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:["A ",(0,a.jsx)(e.strong,{children:"histogram"})," dynamically builds buckets from a numeric field's value based on a specified interval."]}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "query": {\n        "range": {\n            "total_amount": {\n                "gte": 10\n            }\n        }\n    },\n    "aggs": {\n        "amount_distribution": {\n            "histogram": {\n                "field": "total_amount",\n                "interval": 25,\n                "min_doc_count": 1,\n                "extended_bounds": {\n                    "min": 0,\n                    "max": 500\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Date Histogram example:"}),"\n"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "orders_over_time": {\n            "date_histogram": {\n                "field": "purchased_at",\n                "interval": "month",\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"global-aggregations",children:"Global Aggregations"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "query": {\n        "range": {\n            "total_amount": {\n                "gte": 100\n            }\n        }\n    },\n    "size": 0,\n    "aggs": {\n        "all_orders": {\n            "global": {},\n            "aggs": {\n                "stats_amount":{\n                    "stats": {\n                        "field": "total_amount"\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"The global aggregation is not influenced by the search query."}),"\n",(0,a.jsx)(e.li,{children:"It uses the context of the index and type that the query is run against and uses all of the documents that are available within this context."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"missing-field-values",children:"Missing Field Values"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /order/_search\n{\n    "size": 0,\n    "aggs": {\n        "orders_without_status": {\n            "missing": {\n                "field": "status.keyword"\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Since the missing aggregation is a bucket aggregation, it creates a bucket with the orders that either don't have a status field at all or have a value of null."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"aggregating-nested-objects",children:"Aggregating Nested Objects"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-SQL",children:'GET /department/_search\n{\n    "size": 0,\n    "aggs": {\n        "employees": {\n            "nested": {\n                "path": "employees"\n            }\n        }\n    }\n}\n'})})]})}function d(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(c,{...n})}):c(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>o});var a=t(6540);const s={},i=a.createContext(s);function r(n){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:r(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);